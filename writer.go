package fit

import (
	"encoding/binary"
	"fmt"
	"io"
	"reflect"
	"time"
	"unicode/utf8"

	"github.com/tormoder/fit/dyncrc16"
	"github.com/tormoder/fit/internal/types"
)

type encoder struct {
	w    io.Writer
	arch binary.ByteOrder
}

func encodeString(str string) ([]byte, error) {
	bstr := append([]byte(str), '\000')
	if !utf8.Valid(bstr) {
		return nil, fmt.Errorf("Can't encode %+v as UTF-8 string", str)
	}
	return bstr, nil
}

func (e *encoder) writeField(value interface{}, t types.Fit) error {
	switch t.Kind() {
	case types.TimeUTC:
		t := value.(time.Time)
		u32 := encodeTime(t)
		binary.Write(e.w, e.arch, u32)
	case types.TimeLocal:
		return fmt.Errorf("Can't encode TimeLocal")
	case types.Lat:
		lat := value.(Latitude)
		binary.Write(e.w, e.arch, lat.semicircles)
	case types.Lng:
		lng := value.(Longitude)
		binary.Write(e.w, e.arch, lng.semicircles)
	case types.NativeFit:
		if t.BaseType() == types.BaseString {
			str, ok := value.(string)
			if !ok {
				return fmt.Errorf("Not a string: %+v", value)
			}

			var err error
			value, err = encodeString(str)
			if err != nil {
				return fmt.Errorf("Can't encode %+v as UTF-8 string: %v", value, err)
			}
		}
		binary.Write(e.w, e.arch, value)
	default:
		return fmt.Errorf("Unknown Fit type %+v", t)
	}

	return nil
}

type encodeFieldDef struct {
	sindex int // message struct field index
	num    byte
	ftype  types.Fit
}

type encodeMesgDef struct {
	globalMesgNum MesgNum
	localMesgNum  byte
	fields        []encodeFieldDef
}

func (e *encoder) writeMesg(mesg reflect.Value, def *encodeMesgDef) error {
	hdr := byte(def.localMesgNum & 0xF)
	err := binary.Write(e.w, e.arch, hdr)
	if err != nil {
		return err
	}

	for _, f := range def.fields {
		value := mesg.Field(f.sindex).Interface()

		err := e.writeField(value, f.ftype)
		if err != nil {
			return err
		}
	}

	return nil
}

// This would live better in the autogenerated profile.go code
func globalMesgNum(t reflect.Type) MesgNum {
	for i, match := range msgsTypes {
		if t == match {
			return MesgNum(i)
		}
	}

	return MesgNumInvalid
}

func profileFieldDef(m MesgNum) [256]*field {
	return _fields[m]
}

func getFieldBySindex(index int, fields [256]*field) *field {
	for _, f := range fields {
		if f != nil && index == f.sindex {
			return f
		}
	}

	return fields[255]
}

// getEncodeMesgDef generates an appropriate encodeMesgDef to will encode all
// of the valid fields in mesg. Any fields which are set to their respective
// invalid value will be skipped (not present in the returned encodeMesgDef)
func getEncodeMesgDef(mesg reflect.Value, localMesgNum byte) *encodeMesgDef {
	mesgNum := globalMesgNum(mesg.Type())
	allInvalid := getMesgAllInvalid(mesgNum)
	profileFields := profileFieldDef(mesgNum)

	if mesg.NumField() != allInvalid.NumField() {
		panic(fmt.Sprintf("Mismatched number of fields in type %+v", mesg.Type()))
	}

	def := &encodeMesgDef{
		globalMesgNum: mesgNum,
		localMesgNum:  localMesgNum,
		fields:        make([]encodeFieldDef, 0, mesg.NumField()),
	}

	for i := 0; i < mesg.NumField(); i++ {
		if mesg.Field(i).Kind() == reflect.Slice || mesg.Field(i).Interface() == allInvalid.Field(i).Interface() {
			// Don't encode invalid values
			continue
		}

		field := getFieldBySindex(i, profileFields)

		def.fields = append(def.fields, encodeFieldDef{
			sindex: i,
			num:    field.num,
			ftype:  field.t,
		})
	}

	return def
}

func (e *encoder) writeDefMesg(def *encodeMesgDef) error {
	hdr := byte((1 << 6) | def.localMesgNum&0xF)
	err := binary.Write(e.w, e.arch, hdr)
	if err != nil {
		return err
	}

	err = binary.Write(e.w, e.arch, byte(0))
	if err != nil {
		return err
	}

	switch e.arch {
	case binary.LittleEndian:
		err = binary.Write(e.w, e.arch, byte(0))
	case binary.BigEndian:
		err = binary.Write(e.w, e.arch, byte(1))
	}
	if err != nil {
		return err
	}

	err = binary.Write(e.w, e.arch, def.globalMesgNum)
	if err != nil {
		return err
	}

	err = binary.Write(e.w, e.arch, byte(len(def.fields)))
	if err != nil {
		return err
	}

	for _, f := range def.fields {
		if f.ftype.Array() {
			return fmt.Errorf("TODO: Arrays not supported")
		}

		fdef := fieldDef{
			num:   f.num,
			size:  byte(f.ftype.BaseType().Size()),
			btype: f.ftype.BaseType(),
		}

		fmt.Println(fdef)

		err := binary.Write(e.w, e.arch, fdef)
		if err != nil {
			return err
		}
	}

	return nil
}

func (e *encoder) encodeDefAndDataMesg(mesg reflect.Value) error {
	// We'll always just use local ID 0, for simplicity
	// We know the full file contents up-front, so no need to interleave
	def := getEncodeMesgDef(mesg, 0)

	err := e.writeDefMesg(def)
	if err != nil {
		return err
	}

	err = e.writeMesg(mesg, def)
	if err != nil {
		return err
	}

	return err
}

func (e *encoder) encodeFile(file reflect.Value) error {
	/*
	deref := reflect.Indirect(file)
	if deref == file {
		return fmt.Errorf("Indirect failure")
	}
	*/
	deref := file

	for i := 0; i < deref.NumField(); i++ {
		v := deref.Field(i)
		switch v.Kind() {
		case reflect.Struct, reflect.Ptr:
			err := e.encodeDefAndDataMesg(reflect.Indirect(file))
			if err != nil {
				return err
			}
		case reflect.Slice:
			var def *encodeMesgDef
			for j := 0; j < v.Len(); j++ {
				v2 := reflect.Indirect(v.Index(j))

				if j == 0 {
					def = getEncodeMesgDef(v2, 0)
					err := e.writeDefMesg(def)
					if err != nil {
						return err
					}
				}

				err := e.writeMesg(v2, def)
				if err != nil {
					return err
				}
			}
		}
	}


	return nil
}

func Encode(w io.Writer, file *File, arch binary.ByteOrder) error {
	enc := &encoder{
		w: dyncrc16.NewWriter(w),
		arch: arch,
	}

	hdr, err := file.Header.MarshalBinary()
	if err != nil {
		return err
	}

	_, err = enc.w.Write(hdr)
	if err != nil {
		return err
	}

	enc.encodeDefAndDataMesg(reflect.ValueOf(file.FileId))

	var data reflect.Value
	switch file.Type() {
	case FileTypeActivity:
		activity, err := file.Activity()
		if err != nil {
			return err
		}
		data = reflect.ValueOf(*activity)
	case FileTypeDevice:
		device, err := file.Device()
		if err != nil {
			return err
		}
		data = reflect.ValueOf(*device)
	case FileTypeSettings:
		settings, err := file.Settings()
		if err != nil {
			return err
		}
		data = reflect.ValueOf(*settings)
	}

	err = enc.encodeFile(data)
	if err != nil {
		return err
	}

	file.CRC = enc.w.(dyncrc16.Hash16).Sum16()
	err = binary.Write(enc.w, binary.LittleEndian, file.CRC)
	if err != nil {
		return err
	}

	if enc.w.(dyncrc16.Hash16).Sum16() != 0 {
		return fmt.Errorf("CRC error.")
	}

	return nil
}
